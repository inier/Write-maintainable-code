# Mysql 的工作原理

[MySql5.7如何慢查询日志记录](https://blog.csdn.net/jwq101666/article/details/78576142)

[如何查看一个mysql的sql语句的性能](https://blog.csdn.net/jwq101666/article/details/78561022)

[Mysql数据库优化和sql优化方法](https://blog.csdn.net/jwq101666/article/details/79070773)

[PDO如何实现事务的提交](https://blog.csdn.net/jwq101666/article/details/78586295)

[Mysql数据库优化可以从哪几个方面优化](https://blog.csdn.net/jwq101666/article/details/78586513)

[深入理解事务的四种隔离级别](https://blog.csdn.net/jwq101666/article/details/78759300)

刚开始接触一个新的事物的时候，我觉得很有必要从其工作原理入手，弄清楚这个东西的来龙去脉，为接下来的继续深入学习做好铺垫，掌握好其原理有助于我们从整体上来把握这个东西，并且帮助我们在排错过程中理清思路。

接下来，还是从mysql的工作原理开始入手，下面先来一张经典的图：

 ![](/img/111054362.png)

   上面的图就是mysql的内部架构，可以清楚的看到Mysql是由SQL接口，解析器，优化器，缓存，存储引擎组成的。

-+-----------------------------------------------------------------------------------+-

   下面是关于上述部件的介绍：

1. connectors [连接器 接口]
    
    与其他编程语言中的sql 语句进行交互，如php、java等。

2. Management Serveices & Utilities

   系统管理和控制工具

3. Connection Pool (连接池)
   
   管理缓冲用户连接，线程处理等需要缓存的需求

4. SQL Interface (SQL接口)

    接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface
 
5. Parser （解析器）
    SQL命令传递到解析器的时候会被解析器验证和解析。

    主要功能：
    
    - a.将SQL语句分解成数据结构，并将这个结构传递到后续步骤，后面SQL语句的传递和处理就是基于这个结构的
    - b.如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的，语句将不会继续执行下去
 
6. Optimizer (查询优化器)

    SQL语句在查询之前会使用查询优化器对查询进行优化(产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果) 他使用的是“选取-投影-联接”策略进行查询。

    用一个例子就可以理解： select uid,name from user where gender = 1;

    这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤
    这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤
    将这两个查询条件联接起来生成最终查询结果.
 
7. Cache和Buffer (查询缓存)

    如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

    这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等
 
8. Engine (存储引擎)

    存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。

    Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）
 
-+-----------------------------------------------------------------------------------+-


### SQL 语句执行过程

   数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。

   那么Mysql接受到SQL语句后，又是如何处理的呢？

   首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices & Utilities）管理。

当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。

SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：

   (1)由SQL接口丢给后面的解释器（Parser），上面已经说到，解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。

   (2)解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。

   (3)确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。


## 这里有几点需要注意：

(1)如何缓存查询数据？

存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。

(2)buffer与cache的区别？

从上面的图可以看到，缓存那里实际上有buffer和cache两个，那它们之间是否有什么不同呢？简单的说就是，buffer是写缓存，cache是读缓存。

(3)如何判断缓存中是否已缓存需要的数据

这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那么缓存的优势又在哪里？？

实际上，并非如此，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。 

## 为什么需要索引（Why is it needed）?
当数据保存在磁盘类存储介质上时，它是作为数据块存放。

这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。

记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索（Linear Search）的过程，平均需要访问N/2的数据块，N是表所占据的数据块数目。

如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口），那么需要在N个数据块上搜索整个表格空间。

但是对于一个有序字段，可以运用二分查找（Binary Search），这样只要访问log2 (N)的数据块。这就是为什么性能能得到本质上的提高。


### 什么是索引（What is indexing）?
索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序。

副作用是索引需要额外的磁盘空间，对于MyISAM引擎而言，这些索引是被统一保存在一张表中的，这个文件将很快到达底层文件系统所能够支持的大小限制，如果很多字段都建立了索引的话。


索引如何工作（How does it work?）

首先，我们建立一个示范数据库表：
```
字段名       数据类型      大小
id (Primary key) Unsigned INT   4 bytes
firstName        Char(50)       50 bytes
lastName         Char(50)       50 bytes
emailAddress     Char(100)      100 bytes
```
注意：使用char是为了指定准确的磁盘占用大小。这个示范数据库包含500万行，而且没有索引。我们将分析一些查询语句的性能，一个是使用主键id（有序）查询，一个是使用firstName（非关键无序字段）。

例1

我们的示范数据库有r=5,000,000条记录，每条记录长度R=204字节而且使用MyISAM引擎存储（默认数据块大小为B=1024字节），这张表的块因子（blocking factor）会是bfr = (B/R) = 1024/204 = 5 条记录每磁盘数据块。保存这张表所需要的磁盘块为N = (r/bfr) = 5000000/5 = 1,000,000 blocks。

在id字段上的线性搜索平均需要N/2 = 500,000块访问来找到一条记录假设id字段是查询关键值，不过既然id字段是有序的，可以执行一个二分查询，这样平均只需要访问log2 (1000000) = 19.93 = 20 个数据块。我们马上就看到了极大的提高。

现在firstName字段既不是有序的，无法执行二分搜索，数值也不具有唯一性，所以对这张表的查找必须到最后一个记录即全表扫描N = 1,000,000个数据块访问。这就是索引用来改进的地方。

假如索引记录只包含一个索引列以及一个指向原记录数据的指针，那么它显而易见会比原记录（多列）要小。所以索引本身所需要的磁盘块要更少，扫描数目也少。firstName索引表结构如下：
```
Field name       Data type      Size on disk
firstName        Char(50)       50 bytes
(record pointer) Special        4 bytes
```
注意: MySQL里的指针按表大小的不同分别可能是 2, 3, 4 或 5 个字节。

例2

假设我们的数据库有r = 5,000,000 条记录，建立了一个长R = 54字节的索引，并且使用默认磁盘块大小为1,024字节。那么该索引的块因子为bfr = (B/R) = 1024/54 = 18 条记录每磁盘块。容纳这个索引表总共需要的磁盘块为N = (r/bfr) = 5000000/18 = 277,778 块。

现在使用FirstName字段来进行搜索就可以利用索引来提高性能。这允许使用一个二分查找，平均log2 (277778) = 18.08 -> 19次数据块访问。找到实际记录的地址，这需要进一步的块读取，这样总数达到19 + 1 = 20次数据块访问，这和非索引表的数据块访问次数有天壤之别。



### 什么时候使用索引（When should it be used?）
鉴于创建索引需要额外的磁盘空间（上面的例子需要额外的277778个磁盘块），以及太多的索引会导致文件系统大小限制所产生的问题，所以对哪些字段建立索引，什么情况下使用索引，需要审慎考虑。

由于索引只是用来加速数据查询，那么显然对只是用来输出的字段建立索引会浪费磁盘空间以及发生插入、删除操作时的处理时间，所以这种情况下应该尽量避免。此外鉴于二分搜索的特性，数据的基数或独立性是很重要的。在基数为2的字段上建立索引，将把数据分割一半，而基数为1000则将返回大约1000条记录。低基数的二分查找效率将降低为一个线性排序，而且查询优化器可能会在基数小于记录数某个比例时（如30%）的情况下将避免使用索引而直接查询原表，所以这种情况下的索引浪费了空间。