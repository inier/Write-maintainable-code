## 简介

自 PHP 5 起完全重写了对象模型以得到更佳性能和更多特性。这是自 PHP 4 以来的最大变化。PHP 5 具有完整的对象模型。 

PHP 5 中的新特性包括访问控制，抽象类和 final 类与方法，附加的魔术方法，接口，对象复制和类型约束。 

PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。参见对象和引用。 

## 基本概念

class

每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。 

类名可以是任何非 PHP 保留字的合法标签。一个合法类名以字母或下划线开头，后面跟着若干字母，数字或下划线。以正则表达式表示为：[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*。 

一个类可以包含有属于自己的常量，变量（称为"属性"）以及函数（称为"方法"）。

## 属性

类的变量成员叫做"属性"，或者叫"字段"、"特征"，在本文档统一称为"属性"。属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。 

有关 public，protected 和 private 的更多详细信息，请查看访问控制（可见性）。 

Note: 

为了向后兼容 PHP 4，PHP 5 声明属性依然可以直接使用关键字 var 来替代（或者附加于）public，protected 或 private。但是已不再需要 var 了。在 PHP 5.0 到 5.1.3，var 会被认为是废弃的，而且抛出 E_STRICT 警告，但是 5.1.3 之后就不再认为是废弃，也不会抛出警告。 

如果直接使用 var 声明属性，而没有用 public，protected 或 private 之一，PHP 5 会将其视为 public。 

在类的成员方法里面，可以用 ->（对象运算符）：$this->property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property 来访问。更多静态属性与非静态属性的区别参见 Static 关键字。 

当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。 

## 类常量

可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。 

常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。 

接口（interface）中也可以定义常量。更多示例见文档中的接口部分。 

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。 

## 类的自动加载

在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。 

在 PHP 5 中，已经不再需要这样了。 spl_autoload_register() 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 

Tip 
尽管 __autoload() 函数也能自动加载类和接口，但更建议使用 spl_autoload_register() 函数。 spl_autoload_register() 提供了一种更加灵活的方式来实现类的自动加载（同一个应用中，可以支持任意数量的加载器，比如第三方库中的）。因此，不再建议使用 __autoload() 函数，在以后的版本中它可能被弃用。 

Note: 

在 PHP 5.3 之前，__autoload 函数抛出的异常不能被 catch 语句块捕获并会导致一个致命错误（Fatal Error）。自 PHP 5.3 起，能够 thrown 自定义的异常（Exception），随后自定义异常类即可使用。 __autoload 函数可以递归的自动加载自定义异常类。 

Note: 

自动加载不可用于 PHP 的 CLI 交互模式。 

Note: 

如果类名比如被用于 call_user_func()，则它可能包含一些危险的字符，比如 ../。建议您在这样的函数中不要使用用户的输入，起码需要在 __autoload() 时验证下输入。 

Example #1 自动加载示例

本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 MyClass1 和 MyClass2 类。 

```
<?php
spl_autoload_register(function ($class_name) {
    require_once $class_name . '.php';
});

$obj  = new MyClass1();
$obj2 = new MyClass2();
?> 
```

## 构造函数和析构函数

### 构造函数

void __construct([ mixed $args[, $...]] )

PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 


Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。

### 析构函数

void __destruct( void)

PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 

## 访问控制（可见性）

对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 

## 属性的访问控制

类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。 

## 对象继承

继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。 

比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。 

继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。 

Note: 

除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。 

## 范围解析操作符 （::）

范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。 

当在类定义之外引用到这些项目时，要使用类名。 

自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。 

把 Paamayim Nekudotayim 选作双冒号操作符的名字似乎有些奇怪。然而，这是 Zend 开发小组在写 Zend Engine 0.5（被用于 PHP 3 中）时所作出的决定。事实上这个词在希伯莱文就是双冒号的意思。 


## Static（静态）关键字

Tip 
本页说明了用 static 关键字来定义静态方法和属性。static 也可用于定义静态变量以及后期静态绑定。参见上述页面了解 static 在其中的用法。 

声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。 

为了兼容 PHP 4，如果没有指定访问控制，属性和方法默认为公有。 

由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。 

静态属性不可以由对象通过 -> 操作符来访问。 

用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。 

就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。 

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。 

## 抽象类

PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 

继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 


##  对象接口

使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 

接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 

接口中定义的所有方法都必须是公有，这是接口的特性。 


### 实现（implements）

要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 

Note: 

实现多个接口时，接口中的方法不能有重名。 

Note: 

接口也可以继承，通过使用 extends 操作符。 

Note: 

类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 

### 常量

接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。 

## Trait

自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。 

Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。 

Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。 

## 匿名类

PHP 7 开始支持匿名类。 匿名类很有用，可以创建一次性的简单对象。 

## 重载

PHP所提供的"重载"（overloading）是指动态地"创建"类属性和方法。我们是通过魔术方法（magic methods）来实现的。 

当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。本节后面将使用"不可访问属性（inaccessibleproperties）"和"不可访问方法（inaccessiblemethods）"来称呼这些未定义或不可见的类属性或方法。 

所有的重载方法都必须被声明为 public。 

Note: 

这些魔术方法的参数都不能通过引用传递。 

Note: 

PHP中的"重载"与其它绝大多数面向对象语言不同。传统的"重载"是用于提供多个同名的类方法，但各方法的参数类型和个数不同。 

更新日志

版本

说明

5.3.0 新增 __callStatic()魔术方法。可见性未设置为 public 或未声明为 static 的时候会产生一个警告。  

5.1.0 新增 __isset() 和 __unset() 两个魔术方法。  


属性重载
```
public void __set( string $name, mixed $value)

public mixed __get( string $name)

public bool __isset( string $name)

public void __unset( string $name)
```
在给不可访问属性赋值时，__set() 会被调用。 

读取不可访问属性的值时，__get() 会被调用。 

当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 

当对不可访问属性调用 unset() 时，__unset() 会被调用。 

参数 $name 是指要操作的变量名称。__set() 方法的 $value 参数指定了 $name 变量的值。 

属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。从 PHP 5.3.0 起, 将这些魔术方法定义为 static 会产生一个警告。 
Note: 

因为 PHP 处理赋值运算的方式，__set() 的返回值将被忽略。类似的, 在下面这样的链式赋值中，__get() 不会被调用：
```
 $a = $obj->b = 8; 
```
Note: 

在除 isset() 外的其它语言结构中无法使用重载的属性，这意味着当对一

## 遍历对象

PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。 

## 魔术方法

__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 等方法在 PHP 中被称为"魔术方法"（Magicmethods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 
### Caution 
PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。 

__sleep() 和 __wakeup() 

public array __sleep( void)

void __wakeup( void)

serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 


Note: 

__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 


__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 

与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 

__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 

## Final 关键字

PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 

## 对象复制

在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 

对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 

$copy_of_object = clone $object;

当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性仍然会是一个指向原来的变量的引用。 

void __clone( void)

当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 

## 对象比较

PHP 5 中的对象比较要比 PHP 4 中复杂，所期望的结果更符合一个面向对象语言。 

当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。 

而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。 

通过下面的示例可以理解以上原则。

## 类型约束

PHP 5 可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。 

如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。 

类型约束不能用于标量类型如 int 或 string。Traits 也不允许。 

## 后期静态绑定

自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。 

准确说，后期静态绑定工作原理是存储了在上一个"非转发调用"（non-forwardingcall）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的"转发调用"（forwardingcall）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。 

该功能从语言内部角度考虑被命名为"后期静态绑定"。"后期绑定"的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为"静态绑定"，因为它可以用于（但不限于）静态方法的调用。 


self:: 的限制

使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类： 

## 对象和引用

在php5 的对象编程经常提到的一个关键点是"默认情况下对象是通过引用传递的"。但其实这不是完全正确的。下面通过一些例子来说明。 

PHP 的引用是别名，就是两个不同的变量名字指向相同的内容。在 PHP 5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。 

## 对象序列化

序列化对象 - 在会话中存放对象

所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 

为了能够unserialize()一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数spl_autoload_register()来实现。

## OOP 变更日志

PHP 5 OOP 模型的变更将被记录在此。功能的描述与其他相关注意事项记录在了 OOP 5 文档之中。 

版本

说明

7.0.0 Trait 里定义兼容的属性不再产生错误信息。  
5.6.0 增加: __debugInfo() 方法。  
5.5.0 增加: ::class 魔法常量。  
5.5.0 增加: finally 来处理异常。  
5.4.0 增加： traits。  
5.4.0 已变更：如果一个抽象 类定义了构造函数的签名，它将必须被实现。  
5.3.3 已变更： 命名空间 中和类同名的方法不再被作为 构造函数。这个变更不影响非命名空间中的类。  
5.3.0 已变更：类实现接口的方法所具有的默认值不再需要和接口的默认值一致。  
5.3.0 已变更： 现在它也能够通过一个变量来引用一个类（例如，echo $classname::constant;）。这个变量的值不能是一个保留关键词（比如，self、parent 或 static）。  
5.3.0 已变更： 如果重载方法被定义为 static 将导致一个 E_WARNING 级别的错误。同时它也需要强制使用 public 的可见性。  
5.3.0 已变更： 在 5.3.0 之前的版本，__autoload() 函数里抛出的异常不能被 catch 块结构捕获，并会导致一个致命错误。现在在一个前提下 catch 块能够捕获 __autoload 函数中抛出的错误。如果抛出一个自定义异常，这个自定义异常的类必须是可用的。否则 __autoload 函数可能递归自动加载这个自定义异常类。  
5.3.0 新增： __callStatic 方法。  
5.3.0 新增： heredoc 和 nowdoc 支持类的 常量 和属性的定义。注意：heredoc 值必须和双引号字符串遵循同样的规则（比如，变量将被替换）。  
5.3.0 新增： 后期静态绑定。  
5.3.0 新增： __invoke 方法。  
5.2.0 已变更：__toString 方法仅在直接与 echo 或 print 使用时被调用。但是现在它能在任何字符串上下文被调用（比如在 printf() 中使用 %s ），但不是在其他类型的上下文被调用（例如 %d 修饰符）。自 PHP 5.2.0 起，将不具有 __toString 方法的对象转化为字符串将导致一个 E_RECOVERABLE_ERROR 级别的错误。  
5.1.3 已变更：在 PHP 5 之前的版本，var 的使用已被废弃，并将产生一个 E_STRICT 级别的错误。现在它不再被废弃，因此也不会产生错误。  
5.1.0 已变更：现在 __set_state 静态方法在 var_export() 导出类时会被调用。  
5.1.0 新增：__isset 和 __unset 方法。  
